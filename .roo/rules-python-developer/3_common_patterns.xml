<![CDATA[<common_patterns>
  <database_patterns>
    <pattern name="async_database_operations">
      <description>Standard pattern for async database operations using SQLAlchemy 2.0+</description>
      <template><![CDATA[
from typing import List, Optional
from uuid import UUID

from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, update, delete
from sqlalchemy.orm import selectinload

from src.models.note import Note
from src.models.user import User


async def get_note_with_user(session: AsyncSession, note_id: UUID) -> Optional[Note]:
    """Get note with user relationship loaded."""
    stmt = select(Note).options(selectinload(Note.user)).where(Note.id == note_id)
    result = await session.execute(stmt)
    return result.scalar_one_or_none()


async def search_notes_by_content(session: AsyncSession, query: str, limit: int = 10) -> List[Note]:
    """Search notes by content using ILIKE for case-insensitive matching."""
    stmt = select(Note).where(Note.content.ilike(f"%{query}%")).limit(limit)
    result = await session.execute(stmt)
    return result.scalars().all()


async def update_note_status(session: AsyncSession, note_id: UUID, status: str) -> None:
    """Update note status using SQLAlchemy update statement."""
    stmt = update(Note).where(Note.id == note_id).values(status=status)
    await session.execute(stmt)
    await session.commit()
        ]]></template>
    </pattern>

    <pattern name="service_layer_with_error_handling">
      <description>Service layer pattern with comprehensive error handling</description>
      <template><![CDATA[
from typing import List, Optional
from uuid import UUID

from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.exc import SQLAlchemyError

from src.models.note import Note, NoteCreate, NoteUpdate
from src.services.base import BaseService
from src.services.database import DatabaseError


class NoteService(BaseService[Note]):
    """Note service with error handling."""
    
    def __init__(self):
        super().__init__(Note)
    
    async def create_note(self, session: AsyncSession, data: NoteCreate) -> Note:
        """Create a new note with error handling."""
        try:
            note_data = data.model_dump()
            note_data["constitutional_audit"] = {
                "created_by": "system",
                "compliance_checked": True
            }
            return await super().create(session, note_data)
        except SQLAlchemyError as e:
            raise DatabaseError(f"Failed to create note: {str(e)}") from e
    
    async def get_user_notes(self, session: AsyncSession, user_id: UUID) -> List[Note]:
        """Get all notes for a specific user."""
        try:
            stmt = select(self.model_class).where(self.model_class.user_id == user_id)
            result = await session.execute(stmt)
            return result.scalars().all()
        except SQLAlchemyError as e:
            raise DatabaseError(f"Failed to get user notes: {str(e)}") from e
        ]]></template>
    </pattern>
  </database_patterns>

  <api_patterns>
    <pattern name="fastapi_endpoint_structure">
      <description>Standard FastAPI endpoint structure with dependency injection</description>
      <template><![CDATA[
from typing import List
from uuid import UUID

from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.ext.asyncio import AsyncSession

from src.api.dependencies import get_db_session
from src.models.note import Note, NoteCreate, NoteUpdate
from src.services.note_service import NoteService

router = APIRouter(prefix="/notes", tags=["notes"])


@router.post("/", response_model=Note, status_code=status.HTTP_201_CREATED)
async def create_note(
    note_data: NoteCreate,
    session: AsyncSession = Depends(get_db_session)
) -> Note:
    """Create a new note."""
    service = NoteService()
    try:
        return await service.create_note(session, note_data)
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Failed to create note: {str(e)}"
        )


@router.get("/{note_id}", response_model=Note)
async def get_note(
    note_id: UUID,
    session: AsyncSession = Depends(get_db_session)
) -> Note:
    """Get a specific note by ID."""
    service = NoteService()
    note = await service.get_by_id(session, note_id)
    if not note:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Note not found"
        )
    return note


@router.get("/", response_model=List[Note])
async def list_notes(
    skip: int = 0,
    limit: int = 100,
    session: AsyncSession = Depends(get_db_session)
) -> List[Note]:
    """List notes with pagination."""
    service = NoteService()
    return await service.get_all(session, skip=skip, limit=limit)
        ]]></template>
    </pattern>

    <pattern name="mcp_tool_integration">
      <description>Pattern for integrating MCP tools with FastAPI</description>
      <template><![CDATA[
from typing import Any, Dict
from uuid import UUID

from fastapi import APIRouter, Depends, HTTPException
from fastmcp import FastMCP
from pydantic import BaseModel, Field

from src.api.dependencies import get_db_session
from src.services.note_service import NoteService

router = APIRouter(prefix="/mcp", tags=["mcp"])


class SearchNotesInput(BaseModel):
    """Input model for MCP search tool."""
    
    query: str = Field(..., description="Search query")
    limit: int = Field(10, description="Maximum number of results")
    similarity_threshold: float = Field(0.7, description="Minimum similarity score")


class SearchNotesOutput(BaseModel):
    """Output model for MCP search tool."""
    
    results: List[Dict[str, Any]]
    total_count: int
    constitutional_compliance: Dict[str, Any]


@router.post("/search-notes", response_model=SearchNotesOutput)
async def search_notes_mcp(
    input: SearchNotesInput,
    session: AsyncSession = Depends(get_db_session)
) -> SearchNotesOutput:
    """MCP tool for searching notes with semantic search."""
    service = NoteService()
    
    try:
        # Implement semantic search logic
        results = await service.semantic_search(
            session, 
            input.query, 
            input.limit, 
            input.similarity_threshold
        )
        
        return SearchNotesOutput(
            results=results,
            total_count=len(results),
            constitutional_compliance={
                "audit_trail": "search_executed",
                "compliance_checked": True
            }
        )
    except Exception as e:
        raise HTTPException(
            status_code=500,
            detail=f"Search failed: {str(e)}"
        )
        ]]></template>
    </pattern>
  </api_patterns>

  <workflow_patterns>
    <pattern name="spiffworkflow_integration">
      <description>Pattern for integrating SpiffWorkflow with BrainForge services</description>
      <template><![CDATA[
from typing import Any, Dict
from uuid import UUID

from spiffworkflow import SpiffWorkflow
from pydantic import BaseModel, Field

from src.services.research_orchestrator import ResearchOrchestrator


class ResearchWorkflowInput(BaseModel):
    """Input for research workflow."""
    
    topic: str = Field(..., description="Research topic")
    max_sources: int = Field(10, description="Maximum number of sources")
    depth: str = Field("standard", description="Research depth")


class ResearchWorkflow:
    """Research workflow using SpiffWorkflow."""
    
    def __init__(self, orchestrator: ResearchOrchestrator):
        self.orchestrator = orchestrator
        self.workflow = SpiffWorkflow("research_workflow")
    
    async def execute(self, input: ResearchWorkflowInput) -> Dict[str, Any]:
        """Execute research workflow."""
        workflow_data = {
            "topic": input.topic,
            "max_sources": input.max_sources,
            "depth": input.depth,
            "constitutional_audit": {"workflow_started": True}
        }
        
        # Define workflow steps
        steps = [
            self._gather_sources,
            self._analyze_content,
            self._synthesize_findings,
            self._generate_report
        ]
        
        for step in steps:
            workflow_data = await step(workflow_data)
        
        return workflow_data
    
    async def _gather_sources(self, data: Dict[str, Any]) -> Dict[str, Any]:
        """Gather research sources."""
        sources = await self.orchestrator.gather_sources(data["topic"], data["max_sources"])
        data["sources"] = sources
        data["constitutional_audit"]["sources_gathered"] = True
        return data
    
    async def _analyze_content(self, data: Dict[str, Any]) -> Dict[str, Any]:
        """Analyze gathered content."""
        analysis = await self.orchestrator.analyze_content(data["sources"])
        data["analysis"] = analysis
        data["constitutional_audit"]["content_analyzed"] = True
        return data
        ]]></template>
    </pattern>
  </workflow_patterns>

  <testing_patterns>
    <pattern name="async_test_structure">
      <description>Standard structure for async tests with database fixtures</description>
      <template><![CDATA[
import pytest
from uuid import UUID, uuid4
from sqlalchemy.ext.asyncio import AsyncSession

from src.models.note import Note, NoteCreate
from src.services.note_service import NoteService
from tests.conftest import create_test_session


@pytest.mark.asyncio
class TestNoteService:
    """Test suite for NoteService."""
    
    async def test_create_note(self):
        """Test creating a new note."""
        async with create_test_session() as session:
            service = NoteService()
            note_data = NoteCreate(
                title="Test Note",
                content="This is a test note",
                user_id=uuid4()
            )
            
            note = await service.create_note(session, note_data)
            
            assert note.id is not None
            assert note.title == "Test Note"
            assert note.constitutional_audit["compliance_checked"] is True
    
    async def test_get_note_by_id(self):
        """Test getting a note by ID."""
        async with create_test_session() as session:
            service = NoteService()
            note_data = NoteCreate(
                title="Test Note",
                content="This is a test note",
                user_id=uuid4()
            )
            
            created_note = await service.create_note(session, note_data)
            retrieved_note = await service.get_by_id(session, created_note.id)
            
            assert retrieved_note is not None
            assert retrieved_note.id == created_note.id
    
    async def test_search_notes(self):
        """Test searching notes."""
        async with create_test_session() as session:
            service = NoteService()
            note_data = NoteCreate(
                title="Search Test",
                content="This note should be found by search",
                user_id=uuid4()
            )
            
            await service.create_note(session, note_data)
            results = await service.search_notes(session, "search")
            
            assert len(results) > 0
            assert any("search" in note.content.lower() for note in results)
        ]]></template>
    </pattern>

    <pattern name="api_endpoint_tests">
      <description>Test pattern for FastAPI endpoints</description>
      <template><![CDATA[
import pytest
from fastapi.testclient import TestClient
from uuid import uuid4

from src.api.main import app
from src.models.note import NoteCreate


client = TestClient(app)


class TestNotesAPI:
    """Test suite for notes API endpoints."""
    
    def test_create_note(self):
        """Test creating a note via API."""
        note_data = {
            "title": "API Test Note",
            "content": "This note was created via API",
            "user_id": str(uuid4())
        }
        
        response = client.post("/notes/", json=note_data)
        
        assert response.status_code == 201
        data = response.json()
        assert data["title"] == note_data["title"]
        assert "id" in data
    
    def test_get_note_not_found(self):
        """Test getting a non-existent note."""
        non_existent_id = str(uuid4())
        response = client.get(f"/notes/{non_existent_id}")
        
        assert response.status_code == 404
        assert "not found" in response.json()["detail"]
    
    def test_list_notes(self):
        """Test listing notes."""
        response = client.get("/notes/", params={"skip": 0, "limit": 10})
        
        assert response.status_code == 200
        assert isinstance(response.json(), list)
        ]]></template>
    </pattern>
  </testing_patterns>

  <migration_patterns>
    <pattern name="alembic_migration_structure">
      <description>Standard structure for Alembic database migrations</description>
      <template><![CDATA[
"""Add new feature table

Revision ID: 001_add_feature_table
Revises: 
Create Date: 2024-01-01 12:00:00.000000

"""
from alembic import op
import sqlalchemy as sa
from sqlalchemy.dialects import postgresql


# revision identifiers, used by Alembic.
revision = '001_add_feature_table'
down_revision = None
branch_labels = None
depends_on = None


def upgrade() -> None:
    """Upgrade migration."""
    # Create new table
    op.create_table('feature',
        sa.Column('id', postgresql.UUID(as_uuid=True), nullable=False),
        sa.Column('name', sa.String(length=255), nullable=False),
        sa.Column('description', sa.Text(), nullable=True),
        sa.Column('created_at', sa.DateTime(), nullable=False),
        sa.Column('updated_at', sa.DateTime(), nullable=False),
        sa.Column('constitutional_audit', postgresql.JSONB(), nullable=False),
        sa.PrimaryKeyConstraint('id')
    )
    
    # Create index
    op.create_index('ix_feature_name', 'feature', ['name'], unique=False)
    
    # Add column to existing table
    op.add_column('note', sa.Column('feature_id', postgresql.UUID(as_uuid=True), nullable=True))
    op.create_foreign_key('fk_note_feature', 'note', 'feature', ['feature_id'], ['id'])


def downgrade() -> None:
    """Downgrade migration."""
    # Remove foreign key
    op.drop_constraint('fk_note_feature', 'note', type_='foreignkey')
    
    # Remove column
    op.drop_column('note', 'feature_id')
    
    # Remove index
    op.drop_index('ix_feature_name', table_name='feature')
    
    # Remove table
    op.drop_table('feature')
        ]]></template>
    </pattern>
  </migration_patterns>
</common_patterns>]]>